import polars as pl
from src.engine.interfaces import ISystem
from src.server.state import GameState
from src.shared.events import EventRealSecond

class PopulationSystem(ISystem):
    @property
    def id(self) -> str:
        return "base.population"

    @property
    def dependencies(self) -> list[str]:
        return ["base.time"]

    def update(self, state: GameState, delta_time: float) -> None:
        # Filter for the real-second heartbeat
        real_sec_events = [e for e in state.events if isinstance(e, EventRealSecond)]
        
        for event in real_sec_events:
            if event.is_paused or event.game_seconds_passed <= 0:
                continue
                
            days_passed = event.game_seconds_passed / 86400.0
            self._apply_tfr_growth(state, days_passed)

    def _apply_tfr_growth(self, state: GameState, days_passed: float):
        regions = state.get_table("regions")
        
        # --- 2001 CONSTANTS ---
        TFR = 2.7                # Total Fertility Rate (2001 Global Avg)
        FEMALE_RATIO = 0.25      # ~25% of pop are women of childbearing age
        CHILDBEARING_YEARS = 35  # Duration of fertility (ages 15 to 50)
        
        # --- MORTALITY & AGING ---
        # 1 / (Life Expectancy * 365)
        DAILY_DEATH_RATE = 1 / (67 * 365.25) 
        # 1 / (Bracket Duration * 365)
        DAILY_AGING_KIDS = 1 / (15 * 365.25)
        DAILY_AGING_WORK = 1 / (50 * 365.25)

        # 1. Calculate Births based on TFR
        # Math: (Total Pop * % Women * TFR) / (Years of fertility) = Births per Year
        # Then multiply by (days_passed / 365) to get current step.
        annual_births_per_capita = (FEMALE_RATIO * TFR) / CHILDBEARING_YEARS
        birth_step = (annual_births_per_capita / 365.25) * days_passed
        
        death_step = DAILY_DEATH_RATE * days_passed
        aging_kids_step = DAILY_AGING_KIDS * days_passed
        aging_work_step = DAILY_AGING_WORK * days_passed

        # 2. Execute Updates
        upd = regions.with_columns([
            # Births are generated by the productive/fertile population (pop_15_64)
            (pl.col("pop_15_64") * birth_step).alias("_new_births"),
            (pl.col("pop_14") * aging_kids_step).alias("_aging_to_work"),
            (pl.col("pop_15_64") * aging_work_step).alias("_aging_to_retirement"),
            (pl.col("pop_65") * death_step).alias("_deaths"),
        ])

        upd = upd.with_columns([
            (pl.col("pop_14") + pl.col("_new_births") - pl.col("_aging_to_work")).cast(pl.Int64).alias("pop_14"),
            (pl.col("pop_15_64") + pl.col("_aging_to_work") - pl.col("_aging_to_retirement")).cast(pl.Int64).alias("pop_15_64"),
            (pl.col("pop_65") + pl.col("_aging_to_retirement") - pl.col("_deaths")).cast(pl.Int64).alias("pop_65")
        ])

        state.update_table("regions", upd.drop(["_new_births", "_aging_to_work", "_aging_to_retirement", "_deaths"]))